import java.util.*;


/**
约瑟夫问题

https://www.zhihu.com/tardis/zm/art/121159246?source_id=1005


1: 定义 约瑟夫操作 与 约瑟夫环操作
把0,1,2,...,n 共n个数字排成一个圆圈.
从0开始，从这个圆圈里删除第m-1个数字. 称为一次约瑟夫操作.
随后从被删除的数字的下一个数字开始约瑟夫操作, 直到最后只剩一个数字。以上过程称为约瑟夫环操作.

2: 定义 函数f(n,m)
表示对 n 个数字 0, 1, …, n - 1 做约瑟夫环操作，最后剩下的这个数字为f(n,m)


3: 定义 序列g(n,m)
对 n 个数字 0, 1, …, n - 1 做一次约瑟夫操作, 剩下的长度为n-1的序列为g(n,m)
g(n,m) = m, m +1, m+2, ..., n-1, 0, 1, ... ,m-2


4: 定义 函数h(n-1,m)
对序列g(n, m)做约瑟夫环操作,最后剩下的这个数字为h(n-1,m)

可知, f(n,m)=h(n-1,m)


5: 定义 下标映射 p(x) 函数
本质上 h(n-1,m) 与 f(n-1,m) 做了一样的操作, 只是操作数的下标不一样.

h(n-1,m)操作的下标是: g(n,m) = m, m +1, m+2, ..., n-1, 0,   1, ... ,m-2
f(n-1,m)操作的下标是:          0,    1 ,  2, ...,                    n-1

从 f(n-1,m) 到 h(n-1,m) 的下标映射为函数 p(f(n-1,m)) = h(h-1,m).

只要能指定 从 f(n-1,m) 到 h(n-1,m) 的下标映射, 就能递归求解f(n,m)


p(x) 是一个分段函数, 每一段的斜率均为1.    p(x) = (x+m) % n

p(f(n-1,m)) = (f(n-1,m) + m ) % n = h(h-1,m)

6. 递归求解

由定义4得 f(n,m)=h(n-1,m),
由定义5得  (f(n-1,m) + m ) % n = h(h-1,m)

综上,递归求解方程为
f(n,m) = ( f(n-1,m) + m ) % n


时间复杂度O(n)
空间复杂度O(n) // 递归函数调用栈的空间


改成循环, 则可以改善

 */
public class Solution {

    public int LastRemaining_Solution (int n, int m) {
        if(n<1 || m <1){
            return -1;
        }

        if (n == 1) {
            return 0;
        } else {
            return (LastRemaining_Solution(n - 1, m) + m) % n;
        }
    }
}