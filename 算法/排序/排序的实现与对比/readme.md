# 分类

基于相邻元素交换的排序: 冒泡排序、选择排序、插入排序 平均O(N2)

突破O(N2)的排序: 希尔排序/堆排序/归并排序/快排

稳定排序: 归并排序、插入排序、冒泡排序


基于完整数组相邻元素交换的排序: 冒泡排序、选择排序、插入排序, 平均时间复杂度O(n2)

基于相邻元素交换+分治思想的排序: 归并排序 希尔排序 快排 , 平均时间复杂度O(nlogn)

基于相邻元素交换+分治思想的排序: 桶排序 平均时间复杂度O(n+k)

基于非相邻元素的交换: 堆排序(树的思想, 基于树的选择排序, 选的是最值), 时间复杂度O(nlogn)

非交换的排序: 
    计数排序(固定范围内的整数, hash思想) , 时间复杂度O(N), 空间复杂度O(N)
    基数排序(只能适用于整数排序, 利用了整数的性质)


# 冒泡排序
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

# 选择排序
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。


# 插入排序
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

# 桶排序

通过某种hash函数, 数据分桶.

桶内排序, 再把各个桶的排序结果汇总.

什么情况下用痛排序? 数据分布比较均匀.

hash函数的选择: 是区间hash, 比如1-10分一个桶, 10-20分一个桶.

这个划分有一种快排的感觉, 快排就是选一个privot基准, 做区间划分.

不过, 桶排是一开始就分好了区, 快排是在分区内再做分区.

# 堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

## 步骤

1. 创建一个堆
2. 把堆首(最大值/最小值)与堆尾交换. (堆首出列),  堆的size-1
3. 使用shift_down维护堆
4. 重复步骤2/3, 直至堆size=1



# 希尔排序

插入排序 + 分治

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

# 归并排序
分治思想.


# 快排

分治思想.

跟归并排序相比, 快排每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分，这种思路就叫做分治法。



partition: 挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分

partition没有标准的写法, 在网络上流传了多种写法, 都是ok的.



# inplace排序与swap

# 计数排序
1. 找出待排序的数组中最大和最小的元素
2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
4. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1